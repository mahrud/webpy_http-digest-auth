import re
import web
import time
import secret

from Crypto import Random
from Crypto.Hash import HMAC, SHA256, MD5
        
renderer = web.template.render('templates/')

urls = (
    '/', 'digest_auth'
    )

app = web.application(urls, globals())

class digest_auth:        
    def GET(self):
        i = web.input()
        realm = 'Sample HTTP Digest Authentication with web.py'
        domain = ''
        stale = 'FALSE'
        algo = 'MD5'
        qop = 'auth,auth-int' # FIXME: not implemented yet
        auth_param = ''

        H0 = MD5.new()
        R0 = Random.new()
        H0.update("%s" % (R0.read(16).encode('hex')))
        opaque = H0.digest().encode('hex')

        # TODO: what if we calculate nonce based on opague? then we can check
        #       user's nonce just with opague after the first time.
        H0 = MD5.new()
        H0.update("%d:%s:%s" % (time.time(), realm, secret.pw))
        nonce = H0.digest().encode('hex')

        # We can either keep the user:pass,
        users = ['user1', 'user2']
        acl = {
            'user1': '123456',
            'user2': 'qwerty'
            }
        # or we can just store the A1 hashes pre-generated by:
        for identity in acl:
            H1 = MD5.new()
            H1.update("%s:%s:%s" % (identity, realm, acl[identity]))
            acl[identity] = H1.digest().encode('hex')

        # Getting the HTTP_AUTHORIZATION header:
        auth = web.ctx.env.get('HTTP_AUTHORIZATION')
        """
        This is how the user response looks like:
         Authorization: Digest username="Mufasa",
                 realm="testrealm@host.com",
                 nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
                 uri="/dir/index.html",
                 qop=auth,
                 nc=00000001,
                 cnonce="0a4f113b",
                 response="6629fae49393a05397450978507c4ef1",
                 opaque="5ccc069c403ebaf9f0171e9517f40e41"
        """

        if auth:
            # removing the 'Digest' in the beginning:
            auth = re.sub('^Digest ','', auth, re.IGNORECASE)

            # split by '", 's # FIXME: fishy ...
            # auth = re.split(r', ', auth)

            params = dict()
            for param in re.findall(r'(.+?)=(.+?), ', auth):
                params[param[0]] = param[1]
            # TODO: the last parameter (opaque) doesn't fit into the regex. FIXME
            # params[]

            uri = params['uri'][1:-1]
            nonce = params['nonce'][1:-1]
            username = params['username'][1:-1]
            response = params['response'][1:-1]
            method = web.ctx.env.get('REQUEST_METHOD')

            try:
                # Names are based on http://tools.ietf.org/html/rfc2617
#               H1 = MD5.new()
#               H1.update("%s:%s:%s" % (username, realm, password))
#               A1 = H1.digest().encode('hex')
                if username in users:
                    A1 = acl[username]
                else:
                    A1 = ''

                H2 = MD5.new()
                H2.update("%s:%s" % (method, uri))
                A2 = H2.digest().encode('hex')

                KD = MD5.new()
                KD.update("%s:%s:%s" % (A1, nonce, A2))
                digest = KD.digest().encode('hex')

                if digest == response:
                    stale = 'TRUE'
                    return renderer.home('Successful!', 
                        'HTTP Digest Authentication was <b style="color: green">Successful</b>!')
            except KeyError:
                web.ctx.status = '401 Unauthorized'
                return renderer.home('Error 401', '401 Unauthorized')

        web.header('WWW-Authenticate', 'Digest ' +
            'realm="%s", '      % (realm) + 
#           'domain="%s", '     % (domain) + 
            'nonce="%s", '      % (nonce) +
            'opaque="%s", '     % (opaque) +
            'stale="%s", '      % (stale) + 
            'algorithm="%s", '  % (algo) + 
#           'qop="%s", '        % (qop) + 
#           'qop-options="%s", '    % (qop) + 
#           'auth-param="%s", ' % (auth_param) + 
            ''
            )
        """
        This is how the server response looks like:
         HTTP/1.1 401 Unauthorized
         WWW-Authenticate: Digest
                 realm="testrealm@host.com",
                 qop="auth,auth-int",
                 nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
                 opaque="5ccc069c403ebaf9f0171e9517f40e41"
        """
        web.ctx.status = '401 Unauthorized'
        return renderer.home('Error 401','401 Unauthorized')

if __name__ == "__main__":
    app.run()
